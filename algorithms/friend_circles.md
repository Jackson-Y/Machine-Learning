**问题：**
假设一个班上有N个同学。同学之间有些是朋友，有些不是。朋友关系是可以传递的。比如A是B的直接朋友，B是C的直接朋友，那么A是C的间接朋友。我们定义朋友圈就是一组直接或间接朋友的同学。输入一个N*N的矩阵M表示班上的朋友关系，如果M[i][j]=1,那么同学i和同学j是直接朋友。请问该班有多少个朋友圈？

例如输入如下的数组，则表明同学0和同学1是朋友，他们组成一个朋友圈。而同学2一个人组成一个朋友圈。因此输出2。

[[1,1,0],

 [1,1,0],

 [0,0,1]]


首先我们注意到朋友关系是对称的，也就是A和B是朋友，那么B和A自然也是朋友。那么输入的矩阵M应该是沿着对角线对称的。另外，一个人和他自己是朋友，也就是矩阵M中对角线上的所有数字都是对称的。


一个表示N个同学朋友关系的图有N个节点。由于我们知道每个人都是自己的朋友，因此我们在初始化时，这个图有N个子图，每个子图都只包含一个节点。接下来我们扫描矩阵M。当M[i][j]=1时，同学i和同学j是直接朋友，因此他们一定在一个朋友圈里。


这个时候我们要解决两件问题：

（1）如何判断同学i和同学j是不是已经在同一个朋友圈即子图里，也就是判断节点i和节点j是不是联通；
（2）如果同学i和同学j之前不联通（不在同一个子图里），我们如何连接他们所在子图，也就是合并两个子图。


通常我们可以用DFS判断节点i和节点j是否联通。如果一个图有n条边，因此DFS需要O(n)的时间。我们对矩阵M中的每条边的两个节点都要做这样的判断，因此总的时间复杂度是 *O(n^2)*。注意n是图中边的数量。


幸运的是我们可以利用一种叫并查集的数据结构进行优化。顾名思义，这种数据结构主要能高效完成两件事情：
**（1）合并两个子图；**
**（2）判断两个节点是否联通**。
并查集用途正好完美匹配前面我们提到的要解决的两件问题。接下来我们详细讨论怎么使用并查集。


在使用并查集是，每个子图都类似于树状结构。子图中的节点都有父节点，根节点的父节点就是他自身。因此同一个子图的根节点一定是同一个。我们判断两个节点是不是联通也就是它们是不是在同一个子图，只需要看它们的根节点是不是相同就知道了。


我们定义长度为N的数组fathers存储N个节点的父节点。初始化图的时候，每个节点组成一个子图，因此每个节点都是各自子图里的根节点，及所有的fathers[i]=i。


有了这个fathers数组，我们想知道节点i所在的子图的根节点，我们得沿着指向父节点的边遍历，看起来仍然是 *O(n)* 的时间复杂度。但我们在这里做一个优化。


由于我们真正关心的是节点i的根节点是谁而不是它的父节点。因此我们可以在fathers[i]存储它的根节点。当我们第一次找节点i的根节点时，我们还需要沿着指向父节点的边遍历直到找到根节点。一旦我们找到了个它的根节点，我们把根节点存到fathers[i]里面。以后再求第i个节点的根节点时我们马上就知道了。上述的优化叫做 **路径压缩**。


接下来考虑怎么合并两个子图。假设第一个子图的根节点是i，第二个子图的根节点是j。如果我们把fathers[i]设为j，相等于把整个第一个子图挂在了节点j的下面，让第一个子图成为第二个子图的一部分，也就是合并了两个子图。
